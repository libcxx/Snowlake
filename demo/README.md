# Demo

This directory holds the demoware for a brief demonstration of how the
*Snowlake* language and compiler can be used.

## Quick demo

Imagine we are going on the adventure of designing and building the next great
statically typed system programming language, and name it *MyAwesomeLang*.

As a statically typed language, *MyAwesomeLang* would have similar semantics with
regards to static method dispatch. The compiler we are going to build for the
language needs to perform the necessary semantic analysis and type checking for
each static method callsite to ensure that 1). the binding of the method and
supplied arguments is legal, and 2). the type of the return value from any
execution path within the method call can bind with the variable that's going
to be holding the return value.

Implementing such logic in code directly can be tedious, error prone, and may
also lose the potential to be self-documenting. It can also be difficult for
other people reading the code for the first time to quickly understand the
semantics captured behind it.

We can define the semantic rules of such static method dispatch declaratively
with the *Snowlake* language, in a file called
[MyAwesomeLangTypeRules.sl](./MyAwesomeLangTypeRules.sl):

[MyAwesomeLangTypeRules.sl](./MyAwesomeLangTypeRules.sl)

```
group MyAwesomeLang {
  ClassName                      : MyAwesomeLangTypeRules;
  TypeClass                      : TypeCls;
  ProofMethod                    : proveType;
  TypeCmpMethod                  : cmpType;
  TypeAnnotationSetupMethod      : typeAnnotationSetup;
  TypeAnnotationTeardownMethod   : typeAnnotationTeardown;

  inference StaticMethodDispatch {

    globals: [
      SELF_TYPE,
      CLS_TYPE
    ]

    arguments: [
      StaticMethodCallStmt : ASTExpr
    ]

    premises: [
      StaticMethodCallStmt.argument_types            : ArgumentsTypes[];

      StaticMethodCallStmt.callee.parameter_types    : ParameterTypes[];

      ArgumentsTypes[] <= ParameterTypes[] inrange 0..1..ParameterTypes[];

      ArgumentsTypes[0] != SELF_TYPE;

      StaticMethodCallStmt.caller_type : CLS_TYPE while {
        ArgumentsTypes[] <= ParameterTypes[] inrange 1..1..ParameterTypes[];

        StaticMethodCallStmt.return_caller_type      : getBaseType();
      };

      StaticMethodCallStmt.caller_type               : getBaseType();

      StaticMethodCallStmt.return_type               : returnType;
    ]

    proposition : baseType(returnType);
  }
}
```

With the rules defined above, we can invoke the *Snowlake* compiler to
synthesize it into actual C++ interface and implementation code, while
at this directory:

```
$ snowlakec --errors -o ./output MyAwesomeLangTypeRules.sl
```

The *Snowlake* compiler takes the **MyAwesomeLangTypeRules.sl** file as input
and synthesizes the corresponding output (in this case, C++ .h and .cpp files)
that contain the interface and implementation of executing the static type
checking according to the semantic rules defined above.

Once that's done we can take a look at the synthesized output files:

```
$ ls -al ./output/
total 32
drwxrwxr-x  2 x x 4096 Sep  4 17:18 .
drwxrwxr-x 12 x x 4096 Sep  4 17:18 ..
-rw-rw-r--  1 x x  773 Sep  4 17:18 InferenceErrorDefn.cpp
-rw-rw-r--  1 x x  283 Sep  4 17:18 InferenceErrorDefn.h
-rw-rw-r--  1 x x 2166 Sep  4 17:18 MyAwesomeLangTypeRules.cpp
-rw-rw-r--  1 x x  366 Sep  4 17:18 MyAwesomeLangTypeRules.h
```

In this example it would generate the following .h and .cpp files:

[MyAwesomeLangTypeRules.h](./output/MyAwesomeLangTypeRules.h)

```
/**
 * Auto-generated by Snowlake compiler (version 0.0.1).
 */

/**
 * This file was synthesized from MyAwesomeLangTypeRules.sl
 */

#pragma once

#include <cstdlib>
#include <cstddef>
#include <vector>
#include <system_error>

/**
 * This class was synthesized from the "MyAwesomeLangTypeRules" rules group.
 */
class MyAwesomeLangTypeRules
{
public:
    TypeCls StaticMethodDispatch(const ASTExpr& StaticMethodCallStmt, std::error_code*);
};
```

[MyAwesomeLangTypeRules.cpp](./output/MyAwesomeLangTypeRules.cpp)

```
/**
 * Auto-generated by Snowlake compiler (version 0.0.1).
 */

/**
 * This file was synthesized from MyAwesomeLangTypeRules.sl
 */

#include "MyAwesomeLangTypeRules.h"
#include "InferenceErrorDefn.h"

/**
 * This method was synthesized from the "StaticMethodDispatch" inference definition.
 */
TypeCls
MyAwesomeLangTypeRules::StaticMethodDispatch(const ASTExpr& StaticMethodCallStmt, std::error_code* err)
{
    std::vector<TypeCls> ArgumentsTypes = proveType(StaticMethodCallStmt.argument_types);
    std::vector<TypeCls> ParameterTypes = proveType(StaticMethodCallStmt.callee.parameter_types);
    for (size_t i = 0, size_t j = 1; i < ParameterTypes.size(); ++i, ++j) {
        if (!cmpType(ArgumentsTypes[i], ParameterTypes[j], std::less_equal<TypeCls>())) {
            *err = std::error_code(0, inference_error_category);
            return TypeCls();
        }
    }

    if (!cmpType(ArgumentsTypes, SELF_TYPE, std::not_equal_to<TypeCls>())) {
        *err = std::error_code(0, inference_error_category);
        return TypeCls();
    }

    // Type annotation setup.
    typeAnnotationSetup(StaticMethodCallStmt.caller_type, CLS_TYPE);

    for (size_t i = 1, size_t j = 1; i < ParameterTypes.size(); ++i, ++j) {
        if (!cmpType(ArgumentsTypes[i], ParameterTypes[j], std::less_equal<TypeCls>())) {
            *err = std::error_code(0, inference_error_category);
            return TypeCls();
        }
    }

    TypeCls var0 = getBaseType();
    TypeCls var1 = proveType(StaticMethodCallStmt.return_caller_type);
    if (!cmpType(var0, var1, std::equal_to<>())) {
        *err = std::error_code(0, inference_error_category);
        return TypeCls();
    }

    // Type annotation teardown.
    typeAnnotationTeardown(StaticMethodCallStmt.caller_type, CLS_TYPE);
```

The synthesized source code files are intended to be integrated with the
rest of the code for the compiler of our language.
